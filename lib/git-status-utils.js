// Generated by CoffeeScript 1.9.3
(function() {
  var ChildProcess, Fs, GitStatusUtils, Path, Str, _;

  ChildProcess = require("child_process");

  Path = require("path");

  Fs = require("fs");

  _ = require('underscore');

  Str = require("bumble-strings");

  module.exports = GitStatusUtils = (function() {
    function GitStatusUtils() {}


    /*
      Returns a javascript object of information from calling git status, like: 
      ```
      {
        branch: "master"
        remote: "origin/master"
        commitsAheadBehind: -5
        stagedChanges: [
          "new file: docs/api/index.html"
          "modified: package.json"
          ...
        ]
        unstagedChanges: [{
          "deleted: relative/path/to/file.ext"
          ...
        }]
        untrackedFiles: [
          "path/to/file.txt"
          "another-path/to/file.txt"
          ...
        ]
      }
      ```
      Not that remote and commitsAheadBehind are not always given by git status, for example, 
      files a local branch with no tracking remote
     */

    GitStatusUtils.getStatus = function(dirName) {
      var rawStatus;
      rawStatus = this._fetchStatus(dirName);
      return this._parseGitStatus(rawStatus);
    };

    GitStatusUtils._fetchStatus = function(directory) {
      var cmd, flags;
      flags = "";
      cmd = "cd " + directory + " && git status" + flags;
      return ChildProcess.execSync(cmd).toString();
    };

    GitStatusUtils.FILE_BLOCKS = [
      {
        match: /Changes to be committed.*/,
        attr: "stagedChanges"
      }, {
        match: /Changes not staged.*/,
        attr: "unstagedChanges"
      }, {
        match: /Untracked.*/,
        attr: "untrackedFiles"
      }
    ];

    GitStatusUtils._parseGitStatus = function(rawOutput) {
      var affix, branch, commitCount, commitsOff, currentFileBlock, fileBlock, i, isNewFileBlock, j, len, len1, line, lines, match, matches, ofWith, ref, ref1, ref2, remote, status, statusOut;
      lines = rawOutput.split('\n');
      ref = matches = lines[0].match(/On branch (.*)/i), match = ref[0], branch = ref[1];
      if ((matches != null ? matches.length : void 0) > 0) {
        branch = matches[1];
        lines = lines.slice(1);
      } else {
        branch = null;
      }
      matches = lines[0].match(/branch is (up to date|[^\s]*)\s*(of|with)?\s*[\'\"]([^\'\"]*)[\'\"](\s*by (\d*) commit)?/i);
      if (matches != null) {
        match = matches[0], status = matches[1], ofWith = matches[2], remote = matches[3], affix = matches[4], commitCount = matches[5];
        lines = lines.slice(1);
        commitsOff = (function() {
          switch (status) {
            case 'ahead':
              return parseInt(commitCount);
            case 'behind':
              return parseInt(commitCount) * -1;
            default:
              return 0;
          }
        })();
      } else {
        commitsOff = 0;
      }
      statusOut = {
        branch: branch,
        remote: remote,
        commitsAheadBehind: commitsOff,
        stagedChanges: [],
        unstagedChanges: [],
        untrackedFiles: []
      };
      currentFileBlock = null;
      for (i = 0, len = lines.length; i < len; i++) {
        line = lines[i];
        isNewFileBlock = false;
        line = Str.trim(line, {
          all: true
        });
        ref1 = this.FILE_BLOCKS;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          fileBlock = ref1[j];
          if (((ref2 = line.match(fileBlock.match)) != null ? ref2.length : void 0) > 0) {
            currentFileBlock = fileBlock;
            isNewFileBlock = true;
            break;
          }
        }
        if (currentFileBlock == null) {
          continue;
        }
        if (isNewFileBlock || line.match(/\s*\(.*\).*/) || line.length === 0) {
          continue;
        }
        statusOut[currentFileBlock.attr].push(line);
      }
      return statusOut;
    };

    return GitStatusUtils;

  })();

}).call(this);
